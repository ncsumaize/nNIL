chip.snp.header = unlist(chip.snp.header[1,]) #make it a vector
chip.snp.header.dups = duplicated(chip.snp.header) #find the duplicated column names
chip.snp.header[chip.snp.header.dups] = paste0(chip.snp.header[chip.snp.header.dups], "_2") #give B73 and Ki3 replicates unique identifiers
#check if any duplicate column names remain
any(duplicated(chip.snp.header))
names(chip.snp)[10:ncol(chip.snp)] = chip.snp.header
#First drop markers that are INDELs
chip.snp = chip.snp %>%
filter(nchar(REF) == 1 & nchar(ALT) == 1) %>%
filter(REF != "N" & REF != "." & ALT != "N" & ALT != ".")
vcf_to_calls = function(x, ref, alt){
if (is.na(x)) {return(NA)}
if (x == "0/0") {return(ref)}
if (x == "1/1") {return(alt)}
if (x == "0/1" | x == "1/0" | x == "0|1" | x == "1|0") {
het = paste0(ref, "/", alt)
if (het == "A/C" | het == "C/A") {return("M")}
if (het == "A/G" | het == "G/A") {return("R")}
if (het == "A/T" | het == "T/A") {return("W")}
if (het == "C/G" | het == "G/C") {return("S")}
if (het == "C/T" | het == "T/C") {return("Y")}
if (het == "G/T" | het == "T/G") {return("K")}
}
return(NA) #if all else fails
}
vcf_to_calls_by_row = function(row){
#row is one row of the chip.snp data frame
ref = row["REF"]
alt = row["ALT"]
calls = row[10:length(row)]
sapply(calls, vcf_to_calls, ref = ref, alt = alt)
}
chip.snp.calls = apply(chip.snp, 1, vcf_to_calls_by_row)
#this returns matrix rows = samples, cols = markers
row.names(chip.snp.calls) = colnames(chip.snp)[-c(1:9)]
#convert chip.snp metadata into colnames of chip.snp.calls
#ADD 1 TO BP POSITION TO MATCH COORDINATES OF HAPMAP!!!!
colnames(chip.snp.calls) = paste0(chip.snp$`#CHROM`, "_", (as.numeric(chip.snp$`POS (V3)`) +1))
bedChip = chip.snp %>% select(`#CHROM`, `POS (V3)`)
names(bedChip) = c('chrV3', 'startV3')
bedChip = bedChip %>%
mutate(
chrV3 = as.numeric(chrV3),
startV3 = as.numeric(startV3),
endV3 = startV3 + 1,
name = paste0("S", chrV3, "_", startV3),
score = 1,
strand = "+"
)  %>%
filter(!is.na(chrV3)) %>%
select(chrV3, startV3, endV3)
#write.table(bedChip, paste0(base.path,"Data/nNIL_chip_SNP_positions_v3_6col.bed"),
#            row.names = F, col.names = F, quote = F, sep = "\t")
founderVCF = read.vcfR(paste0(base.path, "Data/nNIL_founders_chipSNPs_Hmp321_AGPv3.vcf.gz"), verbose = FALSE )
founder_meta = founderVCF@fix
founder_calls = extract.gt(founderVCF, return.alleles = T)
founder_calls[founder_calls == "."] = NA
biallelic_to_IUPAC = function(x){
if (is.na(x)) {return(x)}
if (x == "A/A") {return("A")}
if (x == "C/C") {return("C")}
if (x == "G/G") {return("G")}
if (x == "T/T") {return("T")}
if (x == "A/C" | x == "C/A") {return("M")}
if (x == "A/G" | x == "G/A") {return("R")}
if (x == "A/T" | x == "T/A") {return("W")}
if (x == "C/G" | x == "G/C") {return("S")}
if (x == "C/T" | x == "T/C") {return("Y")}
if (x == "G/T" | x == "T/G") {return("K")}
return(NA) #in case no match
}
founder_calls_iupac = apply(founder_calls, 1:2, biallelic_to_IUPAC)
colnames(founder_calls_iupac) = sub("282set_", "", colnames(founder_calls_iupac))
colnames(founder_calls_iupac) = sub("KI3", "Ki3", colnames(founder_calls_iupac))
hapmap.markers.df = data.frame(Marker = row.names(founder_calls_iupac)) |>
separate_wider_delim(Marker, delim = "_", names = c("Chr", "Pos"), cols_remove = F) |>
mutate(Chr = as.numeric(Chr),
Pos = as.numeric(Pos)) |>
arrange(Chr, Pos)
founder_calls_iupac = founder_calls_iupac[hapmap.markers.df$Marker,]
chip.snp.subset = chip.snp.calls[,rownames(founder_calls_iupac)]
all(colnames(chip.snp.subset) == rownames(founder_calls_iupac))
chip.snp.subset[!chip.snp.subset %in% c("A", "C", "G", "T")] = NA
founder_calls_iupac[!founder_calls_iupac %in% c("A", "C", "G", "T")] = NA
nil.alleles = apply(chip.snp.subset,2,function(x) sort(unique(x)))
hapmap.alleles = apply(founder_calls_iupac, 1, function(x) sort(unique(x)))
check.complements = function(x){
#x is an index for the identically sorted nil and hapmap.alleles lists
if (all(nil.alleles[[x]] == hapmap.alleles[[x]])) {return(F)} #alleles match
if ((length(nil.alleles[[x]]) != 2) | (length(hapmap.alleles[[x]]) != 2)) {return(F)} #both not biallelic
if ((identical(nil.alleles[[x]], c("A", "C")) & identical(hapmap.alleles[[x]], c("G", "T"))) |
(identical(nil.alleles[[x]], c("A", "G")) & identical(hapmap.alleles[[x]], c("C", "T"))) |
(identical(nil.alleles[[x]], c("C", "T")) & identical(hapmap.alleles[[x]], c("A", "G"))) |
(identical(nil.alleles[[x]], c("G", "T")) & identical(hapmap.alleles[[x]], c("A", "C")))) {return(T)} #these are complementary pairs!
return(F)
}
check.list = unlist(lapply(1:length(nil.alleles), check.complements))
names(check.list) = names(nil.alleles)
compl.alleles = check.list[check.list]
compl.alleles.df = data.frame(Marker = names(compl.alleles)) |>
separate_wider_delim(Marker, delim = "_", names = c('Chr', 'Pos'), cols_remove = F)
compl.alleles.df |> group_by(Chr) |>
summarise(N.compl.SNPs = n())
check.strand = grep("strand=-", chip.snp$INFO)
swap.strands = function(x){
if (is.na(x)) return(x)
if (x == "A") return("T")
if (x == "C") return("G")
if (x == "G") return("C")
if (x == "T") return("A")
return(x)} #if no matches
founder_calls_iupac2 = founder_calls_iupac
founder_calls_iupac2[compl.alleles.df$Marker,] = apply(founder_calls_iupac2[compl.alleles.df$Marker,], 1:2, swap.strands)
chip.snp.founders = chip.snp.subset[!grepl("NIL|DRIL|B73 \\(3.04\\) L2|B73 JL1|B73 LL1|H100|NC262|NC304|Oh7B", rownames(chip.snp.subset)),]
compare_SNPs_whole_genome_nohets = function(x){
line = rownames(chip.snp.founders)[x]
chips = unlist(chip.snp.founders[line,])
#set hets to missing
#hom.calls = c("A", "C", "G", "T")
#chips[!chips %in% hom.calls] = NA
# founders2 = apply(founder_calls_iupac, 1:2, function(x) if(x %in% hom.calls) {x} else {NA})
compare = apply(founder_calls_iupac, 2, FUN = function(y) {sum(y == chips, na.rm = T)/sum(!is.na(y) & !is.na(chips))})
return(compare)
}
whole.list = lapply(1:nrow(chip.snp.founders), compare_SNPs_whole_genome_nohets)
names(whole.list) = rownames(chip.snp.founders)
whole.genome.compare = do.call(rbind, whole.list)
#sort rows and columns alphabetically to make it easier to compare
whole.genome.compare = whole.genome.compare[sort(row.names(whole.genome.compare)), sort(colnames(whole.genome.compare))]
write.csv(whole.genome.compare, file = paste0(base.path, "Output/founders_chip_vs_HapMap_whole_genome.csv"), row.names = T, quote = F)
chip.snp.vs.hapmap = whole.genome.compare[row.names(whole.genome.compare) %in% colnames(whole.genome.compare), colnames(whole.genome.compare) %in% row.names(whole.genome.compare)]
diag(chip.snp.vs.hapmap)
compare_SNPs_whole_genome_nohets2 = function(x){
line = rownames(chip.snp.founders)[x]
chips = unlist(chip.snp.founders[line,])
#set hets to missing
#hom.calls = c("A", "C", "G", "T")
#chips[!chips %in% hom.calls] = NA
# founders2 = apply(founder_calls_iupac, 1:2, function(x) if(x %in% hom.calls) {x} else {NA})
compare = apply(founder_calls_iupac2, 2, FUN = function(y) {sum(y == chips, na.rm = T)/sum(!is.na(y) & !is.na(chips))})
return(compare)
}
whole.list2 = lapply(1:nrow(chip.snp.founders), compare_SNPs_whole_genome_nohets2)
names(whole.list2) = rownames(chip.snp.founders)
whole.genome.compare2 = do.call(rbind, whole.list2)
#sort rows and columns alphabetically to make it easier to compare
whole.genome.compare2 = whole.genome.compare2[sort(row.names(whole.genome.compare2)), sort(colnames(whole.genome.compare2))]
chip.snp.vs.hapmap2 = whole.genome.compare2[row.names(whole.genome.compare2) %in% colnames(whole.genome.compare2), colnames(whole.genome.compare2) %in% row.names(whole.genome.compare2)]
diag(chip.snp.vs.hapmap2)
intros.info = read.csv("C:/Users/jholland/Box/nNIL genotype data Jim and Tao/Output/Individual_Introgressions_chip.csv") |>
filter(grepl("NIL", Line))
markersV3toV4 = read.table("C:/Users/jholland/Box/nNIL genotype data Jim and Tao/nNIL_data_supplement/File_S8.nNIL_chip_SNP_positions_converted_to_V4.bed")
colnames(markersV3toV4) = c('chr_V4', 'startV4', 'pos_V4',  'name', 'score', 'strand')
markersV3toV4 = markersV3toV4 |>
separate_wider_delim(name, delim = "_", names = c("chr_V3", "pos_V3")) |>
mutate(chr_V4 = as.numeric(chr_V4),
pos_V3 = as.numeric(pos_V3))
intros.info2 = merge(intros.info, markersV3toV4, by.x = c('chr', 'pos_leftflank'), by.y = c('chr_V4', 'pos_V4'), all.x = T) |>
rename(chr_V3_left = chr_V3, pos_leftflank_V3 = pos_V3) |>
left_join(markersV3toV4, join_by(chr == chr_V4, pos_rightflank == pos_V4)) |>
rename(chr_V3_right = chr_V3, pos_rightflank_V3 = pos_V3) |>
mutate(pos_leftflank_V3 = ifelse(pos_leftflank == 0, 0, pos_leftflank_V3))
max.markers = markersV3toV4 |> group_by(chr_V3) |>
filter(!is.na(chr_V4)) |>
arrange(desc(pos_V3)) |>
slice_head(n = 1) |>
ungroup() |>
mutate(max_V3 = pos_V3,
chr = as.numeric(sub("S", "", chr_V3))) |>
select(chr, max_V3)
intros.info2 = merge(intros.info2,max.markers, by = 'chr') |>
mutate(pos_rightflank_V3 = ifelse(is.na(pos_rightflank_V3), max_V3, pos_rightflank_V3))
compare_SNPs_in_intros_nohets = function(x){
#x is one row of intros.info2 data frame, becomes a character vector here
#extract the row of chip SNP calls for the current NIL
line_SNPcalls = chip.snp.subset[x['Line'],]
#extract the markers defining the current introgression block
selectMarkers = hapmap.markers.df |>
filter((Chr == as.numeric(x['chr']))  & (Pos >= as.numeric(x['pos_leftflank_V3'])) & (Pos <= as.numeric(x['pos_rightflank_V3']))) |>
pull(Marker)
#subset the current NILs SNP calls to only the current introgression
line_SNPcalls_in_intro = line_SNPcalls[selectMarkers]
#subset the founder SNP calls to the same set of markers
match_founders = founder_calls_iupac2[selectMarkers,]
#compute the match percentage, ignoring hets/NAs
compare = apply(match_founders, 2, FUN = function(y) {sum(y == line_SNPcalls_in_intro, na.rm = T)/sum(!is.na(y) & !is.na(line_SNPcalls_in_intro))})
#also compute the number of SNPs NOT missing (not hets)
N.homoz = sum(!is.na(line_SNPcalls[selectMarkers]))
return(list(compare, length(selectMarkers), N.homoz))
}
#extract all of the nested first components of the list components:
comp.list = apply(intros.info2,1,compare_SNPs_in_intros_nohets)
nNIL_compare = lapply(comp.list, function(x) x[[1]])
nNIL_compare = do.call(rbind, nNIL_compare)
colnames(nNIL_compare) = c(colnames(founder_calls_iupac2))
#extract all of the nested 2nd components of the list components:
n.SNPs = lapply(comp.list, function(x) x[[2]])
n.SNPs = do.call(c, n.SNPs)
#extract all of the nested 3rd components of the list components:
N.homoz = lapply(comp.list, function(x) x[[3]])
N.homoz = do.call(c, N.homoz)
intros.info3 = cbind(intros.info2, nNIL_compare)
intros.info3$N.SNPs = n.SNPs
intros.info3$N.homoz = N.homoz
intros.info3$perc.homoz = intros.info3$N.homoz/intros.info3$N.SNPs
best.matches = apply(nNIL_compare, 1, function(x) colnames(nNIL_compare)[which.max(x)])
matches.80 = apply(nNIL_compare, 1, function(x) x[which.max(x)] > 0.8)
best.matches[!matches.80]= NA
intros.info3$best.matches = best.matches
intros.info4 = intros.info3 |>
separate_wider_delim(cols = Line, delim = "/", names = c("ped.donor", "suffix"), cols_remove = F) |>
mutate(ped.donor = ifelse(ped.donor == "MO17", "Mo17", ped.donor),
ped.donor = ifelse(ped.donor == "KI3", "Ki3", ped.donor))
unique(intros.info4$ped.donor)[!unique(intros.info4$ped.donor) %in% intros.info3$best.matches]
unique(intros.info4$best.matches)[!unique(intros.info4$best.matches) %in% intros.info4$ped.donor]
intros.info4 |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
intros.info.filter = intros.info4 |>
filter(N.homoz >= 50 & perc.homoz >= 0.8)
intros.info.filter |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
nNIL24.subset = read.table("File_S4.bgi_nil_id.txt", sep = "\t", header = T)
intros.info.filter = intros.info.filter |>
mutate(ped.match = ped.donor==best.matches,
subset24 = Line %in% nNIL24.subset$nil_id)
intros.info.filter|>
filter(subset24) |>
group_by(Line, best.matches) |>
summarize(N.intros = n())
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
filter(Line %in% nNIL24.subset$nil_id) |>
group_by(Line, best.matches) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
mismatch.by.NIL |>
filter(N.donor.matches > 1) |>
nrow()
write.csv(intros.info4, paste0(base.path, "Output/Introgression_block_founder_match_summary_chip_data.csv"), row.names = F, quote = F)
write.csv(mismatch.by.NIL, paste0(base.path, "Output/NIL_founder_match_summary_chip_data.csv"), row.names = F, quote = F)
View(mismatch.by.NIL)
View(intros.info.filter)
View(mismatch.by.NIL)
min.N.homoz = 50
intros.info.filter = intros.info |>
filter(N.homoz >= min.N.homoz)
intros.info.filter |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
intros.info.filter = intros.info4 |>
filter(N.homoz >= 50 & perc.homoz >= 0.8)
intros.info.filter |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
nNIL24.subset = read.table("File_S4.bgi_nil_id.txt", sep = "\t", header = T)
intros.info.filter = intros.info.filter |>
mutate(ped.match = ped.donor==best.matches,
subset24 = Line %in% nNIL24.subset$nil_id)
intros.info.filter|>
filter(subset24) |>
group_by(Line, best.matches) |>
summarize(N.intros = n())
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
group_by(Line, best.matches) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
View(mismatch.by.NIL)
View(intros.info.filter)
mismatch.by.NIL = intros.info.filter |>
filter(subset24)
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
group_by(Line, best.matches) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
View(mismatch.by.NIL)
View(mismatch.by.NIL)
mismatch.by.NIL = intros.info.filter |>
filter(subset24)
unique(mismatch.by.NIL$LIne)
unique(mismatch.by.NIL$Line)
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
group_by(Line, best.matches) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
View(mismatch.by.NIL)
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
group_by(Line) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
View(mismatch.by.NIL)
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
group_by(Line) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
unique(intros.info.filter) %in% subset24
unique(intros.info.filter) %in% nNIL24.subset$nil_id
unique(intros.info.filter$Line) %in% nNIL24.subset$nil_id
sum(unique(intros.info.filter$Line) %in% nNIL24.subset$nil_id)
sum(unique(intros.info.filter$Line))
length(unique(intros.info.filter$Line))
length(unique(intros.info$Line))
sum(unique(intros.info$Line) %in% nNIL24.subset$nil_id)
mismatch.by.NIL = intros.info |>
filter(subset24) |>
group_by(Line) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
intros.info4 |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
intros.info4 = intros.info3 |>
separate_wider_delim(cols = Line, delim = "/", names = c("ped.donor", "suffix"), cols_remove = F) |>
mutate(ped.donor = ifelse(ped.donor == "MO17", "Mo17", ped.donor),
ped.donor = ifelse(ped.donor == "KI3", "Ki3", ped.donor))
nNIL24.subset = read.table("File_S4.bgi_nil_id.txt", sep = "\t", header = T)
intros.info.filter = intros.info.filter |>
mutate(ped.match = ped.donor==best.matches)
intros.info4 = intros.info4 |>
mutate(subset24 = Line %in% nNIL24.subset$nil_id)
intros.info4 |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
intros.info.filter = intros.info4 |>
filter(N.homoz >= 50 & perc.homoz >= 0.8)
intros.info.filter |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
intros.info.filter|>
filter(subset24) |>
group_by(Line, best.matches) |>
summarize(N.intros = n())
mismatch.by.NIL = intros.info |>
filter(subset24) |>
group_by(Line) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
mismatch.by.NIL = intros.info4 |>
filter(subset24) |>
group_by(Line) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
mismatch.by.NIL = intros.filter |>
filter(subset24) |>
group_by(Line) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
group_by(Line) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
intros.info4 = intros.info3 |>
separate_wider_delim(cols = Line, delim = "/", names = c("ped.donor", "suffix"), cols_remove = F) |>
mutate(ped.donor = ifelse(ped.donor == "MO17", "Mo17", ped.donor),
ped.donor = ifelse(ped.donor == "KI3", "Ki3", ped.donor))
nNIL24.subset = read.table("File_S4.bgi_nil_id.txt", sep = "\t", header = T)
intros.info.filter = intros.info.filter |>
mutate(ped.match = ped.donor==best.matches)
intros.info4 = intros.info4 |>
mutate(subset24 = Line %in% nNIL24.subset$nil_id)
intros.info4 |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
intros.info.filter = intros.info4 |>
filter(N.homoz >= 50 & perc.homoz >= 0.8)
intros.info.filter |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
intros.info.filter|>
filter(subset24) |>
group_by(Line, best.matches) |>
summarize(N.intros = n())
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
group_by(Line) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
nNIL24.subset = read.table("File_S4.bgi_nil_id.txt", sep = "\t", header = T)
intros.info4 = intros.info3 |>
separate_wider_delim(cols = Line, delim = "/", names = c("ped.donor", "suffix"), cols_remove = F) |>
mutate(ped.donor = ifelse(ped.donor == "MO17", "Mo17", ped.donor),
ped.donor = ifelse(ped.donor == "KI3", "Ki3", ped.donor),
ped.match = ped.donor==best.matches,
subset24 = Line %in% nNIL24.subset$nil_id)
unique(intros.info4$ped.donor)[!unique(intros.info4$ped.donor) %in% intros.info3$best.matches]
unique(intros.info4$ped.donor)[!unique(intros.info4$ped.donor) %in% intros.info3$best.matches]
unique(intros.info4$best.matches)[!unique(intros.info4$best.matches) %in% intros.info4$ped.donor]
intros.info4 |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
intros.info.filter = intros.info4 |>
filter(N.homoz >= 50 & perc.homoz >= 0.8)
intros.info.filter |>
mutate(GROUP = case_when(
is.na(best.matches) ~ "NA",
best.matches == "B73" ~ "B73",
best.matches == ped.donor ~ "CORRECT",
best.matches != ped.donor ~ "WRONG"
)) |>
group_by(GROUP) |>
summarise(N.blocks = n(), min.N = min(N.SNPs), mean.N = mean(N.SNPs), max.N = max(N.SNPs),
min.perc.homoz = min(perc.homoz), mean.perc.homoz = mean(perc.homoz), max.perc.homoz = max(perc.homoz),
min.N.homoz = min(N.homoz), mean.N.homoz = mean(N.homoz), max.N.homoz = max(N.homoz))
intros.info.filter|>
filter(subset24) |>
group_by(Line, best.matches) |>
summarize(N.intros = n())
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
group_by(Line) |>
summarize(N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
mismatch.by.NIL |>
filter(N.donor.matches > 1) |>
nrow()
View(mismatch.by.NIL)
View(intros.info4)
mismatch.by.NIL = intros.info.filter |>
filter(subset24) |>
group_by(Line) |>
summarize(N.blocks = n(), N.mismatch.blocks= sum(! ped.match, na.rm = T), N.NA.blocks = sum(is.na(ped.match)), N.donor.matches = sum(!is.na(unique(best.matches)))) |>
arrange(N.mismatch.blocks)
mismatch.by.NIL |>
filter(N.mismatch.blocks > 0) |>
nrow()
